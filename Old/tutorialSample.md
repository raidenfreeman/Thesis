# Benchmarking και Χρονομέτρηση Κώδικα

## `@time`
Για να μετρήσουμε τις επιδόσεις του κώδικά μας, σε επίπεδο χρόνου, χρησιμοποιούμε το macro `@time`.

**Προσοχή:** Η Julia, όπως και οι περισσότερες JIT-compiled γλώσσες, θα μεταγλωττίσουν/παράγουν ενδιάμεσο κώδικα (bytecode) οποιαδήποτε συνάρτηση/μέθοδο, την πρώτη φορά που καλείται. Αυτό σημαίνει, πως την πρώτη φορά που καλούμε μια συνάρτηση που γράψαμε, θα πρέπει να περιμένουμε να μεταγλωττιστεί. Γι' αυτό, **δεν χρονομετρούμε την 1η κλήση**.

*Προσέξτε ότι, το παραπάνω ισχύει για τα πάντα, ακόμα και ενσωματωμένες συναρτήσεις της Julia base library ή macros. Δηλαδή, ακόμα και το `@time` την πρώτη φορά που θα κληθεί πρέπει να μεταγλωττιστεί.*

```julia
function f(n::Number)
  for i = 0:100000
    n = n+1
  end
  n
end

@time f(3)

@time f(3)
```
```julia
0.003120 seconds (1.36 k allocations: 63.282 KB)
0.000002 seconds (5 allocations: 176 bytes)
```

*Όπως βλέπετε, στην 1η κλήση έχουμε δραματικά περισσότερο χρόνο εκτέλεσης*

## `tic()` `toc()` και `@elapsed`

Στη Julia υπάρχουν και οι συναρτήσεις `tic()` και `toc()` (όπως και στη Matlab). Επίσης υπάρχει και το macro `@elapsed` που μετρά το χρόνο εκτέλεσης. Η κύρια διαφορά τους με το `@time` είναι πως το δεύτερο, μας παρέχει και πληροφορίες για το memory allocation *(επίσης το `@time` επιστρέφει και το αποτέλεσμα που υπολόγισε)*. Αυτό είναι πολύ χρήσιμο για να καταλάβουμε εύκολα αν ο κώδικάς μας έχει κάποιο σημείο που επιδέχεται βελτιστοποίησης. Στην πραγματικότητα, δεν έχουν διαφορά στη χρονομέτρηση, απλά το `@time` είναι πιο χρήσιμο.
