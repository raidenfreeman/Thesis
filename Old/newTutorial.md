

# Benchmarking και Χρονομέτρηση Κώδικα

## `@time`
Για να μετρήσουμε τις επιδόσεις του κώδικά μας, σε επίπεδο χρόνου, χρησιμοποιούμε το macro `@time`.

**Προσοχή:** Η Julia, όπως και οι περισσότερες JIT-compiled γλώσσες, θα μεταγλωττίσουν/παράγουν ενδιάμεσο κώδικα (bytecode) οποιαδήποτε συνάρτηση/μέθοδο, την πρώτη φορά που καλείται. Αυτό σημαίνει, πως την πρώτη φορά που καλούμε μια συνάρτηση που γράψαμε, θα πρέπει να περιμένουμε να μεταγλωττιστεί. Γι' αυτό, **δεν χρονομετρούμε την 1η κλήση**.

*Προσέξτε ότι, το παραπάνω ισχύει για τα πάντα, ακόμα και ενσωματωμένες συναρτήσεις της Julia base library ή macros. Δηλαδή, ακόμα και το `@time` την πρώτη φορά που θα κληθεί πρέπει να μεταγλωττιστεί.*

```julia
function f(n::Number)
  for i = 0:100000
    n = n+1
  end
  n
end

@time f(3)

@time f(3)
```
```julia
0.003120 seconds (1.36 k allocations: 63.282 KB)
0.000002 seconds (5 allocations: 176 bytes)
```

*Όπως βλέπετε, στην 1η κλήση έχουμε δραματικά περισσότερο χρόνο εκτέλεσης*

## `tic()` `toc()` και `@elapsed`

Στη Julia υπάρχουν και οι συναρτήσεις `tic()` και `toc()` (όπως και στη Matlab). Επίσης υπάρχει και το macro `@elapsed` που μετρά το χρόνο εκτέλεσης. Η κύρια διαφορά τους με το `@time` είναι πως το δεύτερο, μας παρέχει και πληροφορίες για το memory allocation *(επίσης το `@time` επιστρέφει και το αποτέλεσμα που υπολόγισε)*. Αυτό είναι πολύ χρήσιμο για να καταλάβουμε εύκολα αν ο κώδικάς μας έχει κάποιο σημείο που επιδέχεται βελτιστοποίησης. Στην πραγματικότητα, δεν έχουν διαφορά στη χρονομέτρηση, απλά το `@time` είναι πιο χρήσιμο.


# Αναπάντεχες Συμπεριφορές

## Μοναδιαίος τελεστής -


```julia
function Oops()
  vectorRow = [4 - 3 5]
  vectorColumn = [8 -1 12]'
  vectorColumn * vectorRow
end
Oops()
```

Μετά την εκτέλεση αυτής της μεθόδου, είναι πολύ πιθανό να αναμέναμε το αποτέλεσμα να είναι ένα δύο επί δύο μητρώο (2x2 Array). Ωστόσο, αυτό που παίρνουμε, είναι ένα μητρώο 3x2!

Αυτό συμβαίνει, γιατί η Julia, αντίθετα με γνωστές C-like γλώσσες, τα κενά δεν αγνοούνται. Παραδείγματος χάρη, το κενό σημαίνει το επόμενο στοιχείο ενός διανύσματος/μητρώου. Στη συγκεκριμένη περίπτωση, το vectorRow είναι ένα διάνυσμα γραμμή, με 2 στοιχεία, μιας και το "-" είναι ο δυαδικός τελεστής αφαίρεσης. Στο vectorColumn όμως, επειδή δεν μεσολαβεί κενό μεταξύ του τελεστή και του αριθμού 1, ο τελεστής θεωρείται ως μοναδιαίος. Αυτό οδηγεί στο να εκληφθεί το "-1" ως ένα όρισμα κατά την αρχικοποίηση του διανύσματος, και όχι ως μέρος μιας έκφρασης προς evaluation (όπως η έκφραση "4 - 3" στο προηγούμενο διάνυσμα). Έτσι έχουμε ένα διάνυσμα τρία επί ένα (3x1), αντί του αναμενόμενου δύο επί ένα, και το αποτέλεσμα του εξωτερικού γινόμενου είναι τρία επί δύο.

```julia
function Oops!()
  vectorColumn = 8 -1
end
Oops!()
```

Σε αυτήν την περίπτωση, σύμφωνα με τα προηγούμενα, μπορεί να περιμέναμε κάποιο συντακτικό σφάλμα. Ωστόσο, στη δεξιά έκφραση, τα κενά, δεν έχουν σημασία, αντίθετα με την έκφραση αρχικοποίησης διανύσματος (πριν), όπου το κενό αντιπροσωπεύει το επόμενο στοιχείο στην γραμμή του διανύσματος. Συνεπώς, εδώ θα κληθεί ο δυαδικός τελεστής "-", μιας και εκτός του ορισμού μητρώων, τα κενά δεν έχουν σημασία.

```julia
function NotJustLiterals()
  vector1 = [2 -sqrt(2)]
  vector2 = [2 - sqrt(2)]
end
NotJustLiterals()
```

Εδώ, παρατηρούμε ότι το κενό (επόμενο στοιχείο πίνακα) έχει προτεραίοτητα της αφαίρεσης, ανεξαρτήτως αν πρόκειται για literal ή αποτέλεσμα συνάρτησης. Το vector1 θα έχει δύο στοιχεία, ενώ το vector2 θα έχει μόνο ένα, μιας και εκτελείται αφαίρεση.
